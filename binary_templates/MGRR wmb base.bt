typedef struct {
        float  x;
        float  y;
        float  z;
} vector<read=vectorRead>;

string vectorRead( vector &value ) {
    string s;
    SPrintf(s, "x: %f, y: %f, z: %f", value.x, value.y, value.z);
    return s;
}

typedef struct {
        float   x;
        float   y;
        float   z;
        float   w;
} vector4<read=vector4Read>;

string vector4Read( vector4 &value ) {
    string s;
    SPrintf(s, "x: %f, y: %f, z: %f, w: %f", value.x, value.y, value.z, value.w);
    return s;
}

typedef struct {
    hfloat u;
    hfloat v;
} mapping_t<read=mapping_tRead>;

string mapping_tRead( mapping_t &value ) {
    string s;
    SPrintf(s, "u: %f, v: %f", value.u, value.v);
    return s;
}

string ubyteListRead( ubyteList &value ) {
    string s;
    SPrintf(s, "%3d, %3d, %3d, %3d", value.val[0], value.val[1], value.val[2], value.val[3]);
    return s;
}
struct {
	char    id[4]; //WMB4
    uint32  u_a;
    uint32  vertexFormat<format=hex, comment="0x30: bone infos, 0x200: mapping2, 0x10000: color">;
    uint16  u_b;
    int16   u_c;
    vector  pos1;
    vector  pos2;
    uint32  offsetVertexGroups<format=hex>;
    uint32  numVertexGroups;
    uint32  offsetBatches<format=hex>;
    uint32  numBatches;
    uint32  offsetBatchDescription<format=hex>;
    uint32  offsetBones<format=hex>;
    uint32  numBones;
    uint32  offsetBoneIndexTranslateTable<format=hex>;
    uint32  sizeBoneIndexTranslateTable;
    uint32  offsetBoneSets<format=hex>;
    uint32  numBoneSets;
    uint32  offsetMaterials<format=hex>;
    uint32  numMaterials;
    uint32  offsetTextures<format=hex>;
    uint32  numTextures;
    uint32  offsetMeshes<format=hex>;
    uint32  numMeshes;
    uint32  offsetMystery<format=hex>;
} header;

if( header.offsetVertexGroups != 0 ) {
    FSeek( header.offsetVertexGroups );
    struct {
        uint32  offsetVertexes <format=hex>;
        uint32  offsetVertexesExData <format=hex>;
        uint32  unknownOffsets[2] <format=hex>;
        uint32  numVertexes;
        uint32  offsetIndexes <format=hex>;
        uint32  numIndexes;
        local uint32 pos = FTell();
        FSeek(offsetVertexes);
        switch (header.vertexFormat) {
        case 0x10337:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   boneIndexes;
                ubyteList   boneWeights;
            } vertexes[numVertexes];
            FSeek(offsetVertexesExData);
            struct {
                ubyteList   color;
                mapping_t   mapping2;
            } vertexesExData[numVertexes];
            break;
        case 0x10307:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   color;
                mapping_t   mapping2;
            } vertexes[numVertexes];
            break;
        case 0x10137:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   boneIndexes;
                ubyteList   boneWeights;
            } vertexes[numVertexes];
            FSeek(offsetVertexesExData);
            struct {
                ubyteList   color;
            } vertexesExData[numVertexes];
            break;
        case 0x10107:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   color;
            } vertexes[numVertexes];
            break;
        case 0x337:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   boneIndexes;
                ubyteList   boneWeights;
            } vertexes[numVertexes];
            FSeek(offsetVertexesExData);
            struct {
                ubyteList   color;
                mapping_t   mapping2;
            } vertexesExData[numVertexes];
            break;
        case 0x137:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
                ubyteList   boneIndexes;
                ubyteList   boneWeights;
            } vertexes[numVertexes];
            break;
        case 0x107:
            struct {
                vector      position;
                mapping_t   mapping;
                normals_t   normal;
                tangents_t  tangents;
            } vertexes[numVertexes];
            break;
        }

        FSeek(offsetIndexes);
        uint16 indexes[numIndexes];
        FSeek(pos);
    } vertexGroups[header.numVertexGroups] <optimize=false>;
}

if ( header.offsetBatches != 0 ) {
    FSeek( header.offsetBatches );
    struct {
        uint32  vertexGroupIndex;
        int32   vertexStart;
        int32   indexStart;
        uint32  numVertices;
        uint32  numIndices;
    } batches[header.numBatches];
}

typedef struct {
    uint32  batchIndex;
    uint32  meshIndex;
    uint16  materialIndex;
    uint16  boneSetsIndex;
    uint32  u_a;
} batchData_t;

if ( header.offsetBatchDescription != 0 ) {
    FSeek( header.offsetBatchDescription );
    struct {
        uint32  offsetBatchData<format=hex>;
        uint32  numBatchData;
        uint32  offsetBatchData1<format=hex>;
        uint32  numBatchData1;
        uint32  offsetBatchData2<format=hex>;
        uint32  numBatchData2;
        uint32  offsetBatchData3<format=hex>;
        uint32  numBatchData3;
    } batchDescriptions;
    if ( batchDescriptions.offsetBatchData != 0 ) {
        FSeek( batchDescriptions.offsetBatchData );
        batchData_t batchData[batchDescriptions.numBatchData];
    }
    if ( batchDescriptions.offsetBatchData1 != 0 ) {
        FSeek( batchDescriptions.offsetBatchData1 );
        batchData_t batchData1[batchDescriptions.numBatchData1];
    }
    if ( batchDescriptions.offsetBatchData2 != 0 ) {
        FSeek( batchDescriptions.offsetBatchData2 );
        batchData_t batchData2[batchDescriptions.numBatchData2];
    }
    if ( batchDescriptions.offsetBatchData3 != 0 ) {
        FSeek( batchDescriptions.offsetBatchData3 );
        batchData_t batchData3[batchDescriptions.numBatchData3];
    }
}

if ( header.offsetBones != 0 ) {
    struct {
        int16   unknownNumber;
        int16   unknownNumber2; //one is global index
        int16   parentIndex;
        int16   u_b;//rotation order?
        vector  relativePosition;
        vector  position;
    } bones[header.numBones];
}

if ( header.offsetBoneIndexTranslateTable != 0 ) {
FSeek( header.offsetBoneIndexTranslateTable );
    struct {
        int16 firstLevel[16];
        local int i;
        local int j = 0;
        for (i = 0; i < 16; i++) {
            if ( firstLevel[i] != -1 ) { 
                j += 1;
            }
        }
        int16 secondLevel[j*16];
        local int k = 0;
        for (i = 0; i < j*16; i++) {
            if ( secondLevel[i] != -1 ) {
                k += 1;
            }
        }
        int16 thirdLevel[k*16];
    } BoneIndexTranslateTable;
}

if ( header.offsetBoneSets != 0 ) {
    FSeek( header.offsetBoneSets );
    struct {
        uint32  offsetBoneRefs<format=hex>;
        uint32  numBones;
        local uint32 pos = FTell();
        FSeek(offsetBoneRefs);
        ubyte boneRefs[numBones];
        FSeek(pos);
    } boneSets[header.numBoneSets]<optimize=false>;  
}

if ( header.offsetMaterials != 0 ) {
    FSeek( header.offsetMaterials );
    struct {
        uint32  offsetShaderName <format=hex>;
        uint32  offsetTextures <format=hex>;
        uint32  u_a;
        uint32  offsetParameters <format=hex>;
        uint16  numTextures;
        uint16  u_c;
        uint16  u_d;
        uint16  numParameters;
        local uint32 pos = FTell();
        FSeek(offsetShaderName);
        char  shaderName[16];
        FSeek(offsetTextures);
        struct {
            uint32  tex0;
            uint32  albedoMap;
            uint32  tex2;
            uint32  tex3;
            uint32  tex4;
            uint32  tex5;
            uint32  tex6;
            uint32  normalMap;
        } textureIndexes;
        FSeek(offsetParameters);
        vector4 parameters[numParameters/4];
        FSeek(pos);
    } materials[header.numMaterials]<optimize=false>;
}

if ( header.offsetTextures != 0 ) {
    FSeek(header.offsetTextures);
    struct {
        uint32  flags<format=hex>;
        uint32  id<format=hex>;
    } textures[header.numTextures];
}

if ( header.offsetMeshes != 0 ) {
    FSeek(header.offsetMeshes);
    struct {
        uint32  offsetName<format=hex>;
        float   boundingBox[6];
        uint32  offsetBatches<format=hex>;
        uint32  numBatches;
        uint32  offsetBatches1<format=hex>;
        uint32  numBatches1;
        uint32  offsetBatches2<format=hex>;
        uint32  numBatches2;
        uint32  offsetBatches3<format=hex>;
        uint32  numBatches3;
        uint32  offsetMaterials<format=hex>;
        uint32  numMaterials;
        local uint32 pos = FTell();
        FSeek(offsetName);
        string  name;
        if (offsetBatches != 0) {
            FSeek(offsetBatches);
            uint16  batches[numBatches];
        }
        if (offsetBatches1 != 0) {
            FSeek(offsetBatches3);
            uint16  batches3[numBatches3];
        }
        if (offsetBatches2 != 0) {
            FSeek(offsetBatches3);
            uint16  batches3[numBatches3];
        }
        if (offsetBatches3 != 0) {
            FSeek(offsetBatches3);
            uint16  batches3[numBatches3];
        }
        FSeek(offsetMaterials);
        uint16  materials[numMaterials];
        FSeek(pos);
    } meshes[header.numMeshes]<optimize=false>;
}

if ( header.offsetMystery != 0 ) {
    FSeek(header.offsetMystery);
    struct {
        uint32  offsetUnknown1<format=hex>;
        uint32  numUnknown1;
        uint32  offsetUnknown2<format=hex>;
        uint32  numUnknown2;
        uint32  offsetUnknown3<format=hex>;
        uint32  numUnknown3;
        uint32  offsetUnknown4<format=hex>;
        uint32  numUnknown4;
        uint32  offsetUnknown5<format=hex>;
        uint32  numUnknown5;
        uint32  offsetUnknown6<format=hex>;
        uint32  numUnknown6;
        uint32  offsetUnknown7<format=hex>;
        uint32  numUnknown7;
        uint32  offsetUnknown8<format=hex>;
        uint32  numUnknown8;
        uint32  offsetUnknown9<format=hex>;
        uint32  numUnknown9;
        
        FSeek(offsetUnknown1);
        struct {
            uint32  offsetName<format=hex>;
            int16   unknownFlag1;
            int16   unknownFlag2;
            local uint32 pos = FTell();
            FSeek(offsetName);
            string name;
            FSeek(pos);
        } unknown1[numUnknown1];

        FSeek(offsetUnknown2);
        struct {
            vector  posA;
            // Unless it's 4 vector4's and a vector.
            int16   unknownFlagA1;
            int16   unknownFlagA2;
            vector  posB;
            int16   unknownFlagB1;
            int16   unknownFlagB2;
            vector  posC;
            int16   unknownFlagC1;
            int16   unknownFlagC2;
            vector  posD;
        } unknown2[numUnknown2];

        FSeek(offsetUnknown3);
        struct {
            uint32  offsetUnknownA<format=hex>;
            uint32  numUnknownA;
            local uint32 pos = FTell();
            
            FSeek(offsetUnknownA);
            struct {
                // Well, that's the obvious guess, vector4.
                vector4 posA1;
                vector4 posA2;
                vector4 posA3;
                vector4 posA4;
            } unknown3A[numUnknownA];
            FSeek(pos);
        } unknown3[numUnknown3];

        FSeek(offsetUnknown4);
        struct {
            vector  pos1;
            vector  pos2;
            vector  pos3; // All zeroes
            uint32  unknown4A; // 1
            uint32  offsetUnknown4B<format=hex>;
            uint32  startIndex4C; // 0, 190, 284
            uint32  indexCount4D; // 190, 94, 330
            uint32  startIndex4E; // 0, 564, 876
            uint32  indexCount4F; // 564, 312, 708
            local uint32 pos = FTell();

            FSeek(offsetUnknown4B);
            struct {
                uint32  unknown4B1;
                uint32  unknown4B2;
                uint32  unknown4B3; // only one that's nonzero. Seen as 139, 12, 90, 0, 52, 76, 112...
                // well, it gets more varied in later entries.
                uint32  unknown4B4;
                uint32  unknown4B5;
                uint32  unknown4B6;
                uint32  unknown4B7;
                uint32  unknown4B8;
                uint32  unknown4B9;
                uint32  unknown4B10;
                uint32  unknown4B11;
                uint32  unknown4B12;
                uint32  unknown4B13;
                uint32  unknown4B14;
                uint32  unknown4B15;
                uint32  unknown4B16;
                uint32  unknown4B17;
                uint32  unknown4B18;
                uint32  unknown4B19;
                uint32  unknown4B20;
            } unknown4B
            FSeek(pos);
        } unknown4[numUnknown4];

        FSeek(offsetUnknown5);
        struct {
            uint32  unknown5A; // 6
            uint32  unknown5B; // 1
            uint32  unknown5C; // 0x11
            uint32  offsetUnknown5D<format=hex>;
            uint32  numUnknown5D;
            local uint32 pos = FTell();

            FSeek(offsetUnknown5D);
            struct {
                uint32  offset5DContent<format=hex>;
                uint32  num5DContent;
                local uint32 pos5D = FTell();
                FSeek(offset5DContent);
                int16 unknownContent5D[num5DContent]; // this name is shit
                FSeek(pos5D);
            } unknown5D[numUnknown5D];
            FSeek(pos);
        } unknown5[numUnknown5];

        FSeek(offsetUnknown6);
        struct {
            uint32  offsetUnknown6A<format=hex>;
            uint32  offsetUnknown6B<format=hex>;
            uint32  numUnknown6A;
            uint32  numUnknown6B;
            local uint32 pos = FTell();

            // the content of this section is actually the end of the file, though the headers aren't

            FSeek(offsetUnknown6A);
            vector4 unknown6A[numUnknown6A]; // last float usually 1

            FSeek(offsetUnknown6B);
            int16 unknown6B[numUnknown6B];
            FSeek(pos);
        } unknown6[numUnknown6];

        // both offset 8 and 9 are somehow before 7

        FSeek(offsetUnknown7);
        struct {
            vector4 unknown7A;
            vector4 unknown7B;
            uint32  unknown7C; // 0
            uint32  unknown7D; // 18, 8, 14, 12...
            uint32  unknown7E; // 0
            uint32  unknown7F; // 36, 72, 36, 60...
        } unknown7[numUnknown7];

        // and offset 9 is still before offset 8.
        // Really, this all went to hell after the offset 6 headers.

        FSeek(offsetUnknown8);
        struct {
            vector  unknown8A;
            vector  unknown8B;
            vector  unknown8C;
            vector  unknown8D;
            vector  unknown8E;
            // this could be a sixth vector, but it isn't... so why the floats?
            uint32  unknown8F; // 0, 9, 10, 11...
            float   unknown8G; // 1
            float   unknown8H;
            int16   unknown8I; // 1, 1, 2, 11...
            int16   unknown8J; // 2
            uint32  unknown8K; // 0
            uint32  unknown8L; // 0, 1, 2, 3... (promising)
            uint32  unknown8M; // 1
        } unknown8[numUnknown8];

        FSeek(offsetUnknown9); // read: just after the offset 6 headers
        struct {
            int16   unknown9A; // 0, 2, 3, 4...
            int16   unknown9B; // -1, 0, 1, 2...
            int16   unknown9C; // 0, 1, 3, 4...
            int16   unknown9D; // 1, 2, 1, 1...
            uint32  unknown9E; // 1. unless it's an int16 1 followed by an int16 0.
        } unknown9[numUnknown9];
    } mystery;
